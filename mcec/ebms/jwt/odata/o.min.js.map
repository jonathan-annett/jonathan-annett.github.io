{"version":3,"file":"o.min.js","sources":["../../src/o.ts","../../src/ORequest.ts","../../src/OBatch.ts","../../src/OHandler.ts"],"sourcesContent":["import { OdataConfig } from \"./OdataConfig\";\nimport { OHandler } from \"./OHandler\";\n\n/**\n * Use the 'o'-function to initialize a request directly or use the returned\n * handler to store the settings.\n *\n * Use o() directly jquery like:\n * @example\n * ```typescript\n *  await o('https://rootUrl').get('resource').query();\n * ```\n *\n * Or with a handler:\n * @example\n * ```typescript\n *  const oHandler = o('https://rootUrl');\n *  await oHandler.get('resource').query({ $top: 2 });\n * ```\n *\n * @param rootUrl The url to query\n * @param config The odata and fetch configuration.\n */\nexport function o(rootUrl: string | URL, config: Partial<OdataConfig> = {}) {\n  // set the default configuration values\n  const defaultConfigValues: OdataConfig = {\n    batch: {\n      boundaryPrefix: \"batch_\",\n      changsetBoundaryPrefix: \"changset_\",\n      endpoint: \"$batch\",\n      headers: new Headers({\n        \"Content-Type\": \"multipart/mixed\",\n      }),\n      useChangset: false,\n      useRelativeURLs: false,\n    },\n    credentials: \"omit\",\n    fragment: \"value\",\n    headers: new Headers({\n      \"Content-Type\": \"application/json\",\n    }),\n    mode: \"cors\",\n    redirect: \"follow\",\n    referrer: typeof window === \"undefined\" ? undefined : \"client\",\n    onStart: () => null,\n    onError: () => null,\n    onFinish: () => null,\n  };\n\n  const mergedConfig: OdataConfig = { ...defaultConfigValues, ...config };\n  if (typeof rootUrl === \"string\") {\n    try {\n      // we assuming a resource\n      const configUrl = (mergedConfig.rootUrl ||\n        window.location.href) as string;\n      rootUrl = new URL(\n        rootUrl,\n        configUrl.endsWith(\"/\") ? configUrl : `${configUrl}/`\n      );\n    } catch (ex) {\n      // no window?!\n      rootUrl = new URL(rootUrl as string, mergedConfig.rootUrl);\n    }\n  }\n  mergedConfig.rootUrl = rootUrl;\n  return new OHandler(mergedConfig);\n}\n\n/**\n * Default exports\n */\nexport * from \"./OBatch\";\nexport * from \"./OdataConfig\";\nexport * from \"./OdataQuery\";\nexport * from \"./OHandler\";\nexport * from \"./ORequest\";\n","import { OdataQuery } from \"./OdataQuery\";\n\nconst encodeURIComponentStrict = (str: string) =>\n  encodeURIComponent(str).replace(\n    /[!'()*]/g,\n    (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`\n  );\n\nexport class ORequest {\n  public url: URL;\n\n  constructor(url: URL | string, public config: RequestInit) {\n    if (typeof url === \"string\") {\n      this.url = new URL(url);\n    } else {\n      this.url = url as URL;\n    }\n  }\n\n  public get fetch() {\n    const req = new Request(this.url.href, this.config);\n    return fetch(req, this.config);\n  }\n\n  public applyStringQuery(query: string, configQuery: URLSearchParams | OdataQuery = {}) {\n    const searchParams = new URLSearchParams(query);\n    searchParams.forEach((value, key) => {\n      if (!query.hasOwnProperty(key)) {\n        configQuery[key] = value;\n      }\n    });\n    return this.applyQuery(configQuery);\n  }\n\n  public applyQuery(query: OdataQuery = {}) {\n    this.url.searchParams.forEach((value, key) => {\n      if (!query.hasOwnProperty(key)) {\n        query[key] = value;\n      }\n    });\n\n    this.url.search = Object.entries(query)\n      .map(\n        ([key, value]) =>\n          `${encodeURIComponentStrict(key)}=${encodeURIComponentStrict(value)}`\n      )\n      .join(\"&\");\n    return this;\n  }\n}\n","import { OdataConfig } from \"./OdataConfig\";\nimport { OdataQuery } from \"./OdataQuery\";\nimport { ORequest } from \"./ORequest\";\n\nconst CRLF = \"\\r\\n\";\n\nexport class OBatch {\n  // \"\" here prevents 'undefined' at start of body under some conditions.\n  private batchBody = \"\";\n  private batchUid;\n  private batchConfig: OdataConfig;\n\n  constructor(\n    resources: ORequest[],\n    config: OdataConfig,\n    query?: OdataQuery,\n    private changeset: boolean = false,\n  ) {\n    this.batchConfig = { ...config, ...config.batch };\n    this.batchUid = this.getUid();\n    (this.batchConfig.headers as Headers).set(\n       \"Content-Type\",\n       `multipart/mixed; boundary=${this.batchUid}`,\n    );\n\n    if (this.batchConfig.batch.useChangset) {\n      resources = this.checkForChangset(resources, query);\n    } else {\n      this.batchBody += `--${this.batchUid}`;\n    }\n\n    resources.forEach(\n      (req) => req.config.method === \"GET\" && req.applyQuery(query),\n    );\n    let contentId = 0;\n    this.batchBody += resources.map((req) => {\n      contentId++;\n      return [\n        \"\",\n        \"Content-Type: application/http\",\n        \"Content-Transfer-Encoding: binary\",\n        `Content-ID: ${contentId}`,\n        \"\",\n        `${req.config.method} ${this.getRequestURL(req)} HTTP/1.1`,\n        `${this.getHeaders(req)}`,\n        `${this.getBody(req)}`\n      ].join(CRLF);\n    }).join(`${CRLF}--${this.batchUid}`);\n\n    this.batchBody += `${CRLF}--${this.batchUid}--${CRLF}`;\n    if(!changeset){\n      (this.batchConfig.headers as Headers).set(\n        \"Content-Type\",\n        `multipart/mixed;boundary=${this.batchUid}`,\n      );\n    }\n  }\n\n  public async fetch(url: URL) {\n    const req = new ORequest(url, {\n      ...this.batchConfig,\n      body: this.batchBody,\n      method: \"POST\",\n    });\n    const res: Response = await req.fetch;\n    if (res.status === 200) {\n      const data = await res.text();\n      return this.parseResponse(data, res.headers.get(\"Content-Type\"));\n    } else {\n      throw res;\n    }\n  }\n\n  public parseResponse(responseData: string, contentTypeHeader: string): any {\n    const headers = contentTypeHeader.split(\"boundary=\");\n    const boundary = headers[headers.length - 1];\n    const splitData = responseData.split(`--${boundary}`);\n    splitData.shift();\n    splitData.pop();\n    let wasWithChangesetresponse = false;\n    const parsedData = splitData.map((data) => {\n      const dataSegments = data.trim().split(\"\\r\\n\\r\\n\");\n      if (dataSegments.length === 0) {\n        // we are unable to parse -> return all\n        return data;\n      } else if (dataSegments.length > 3) {\n        const header = dataSegments.find(\n            (x) => x.startsWith(\"Content-Type: \") && x.includes(\"boundary=changesetresponse_\"));\n        if (!header) {\n          return data;\n        }\n        dataSegments.shift();\n        wasWithChangesetresponse = true;\n        return this.parseResponse(dataSegments.join(\"\\r\\n\\r\\n\"), header);\n      } else {\n        var contentIdHeader = dataSegments[0].split(\"\\r\\n\").find(function (x) { return x.startsWith(\"Content-ID: \"); });\n        if (contentIdHeader) {\n          try {\n            var contentId = parseInt(contentIdHeader.substring(12), 10);\n          } catch (ex) {\n          }\n        }\n        var status = +dataSegments[1].split(\" \")[1];\n        if (dataSegments.length === 3) {\n          // if length == 3 we have a body, try to parse if JSON and return that!\n          var body;\n          try {\n            const parsed = JSON.parse(dataSegments[2]);\n            const hasFragment = parsed[this.batchConfig.fragment];\n            body = hasFragment || parsed;\n          } catch (ex) {\n            body = dataSegments[2];\n          }\n        }\n        return { contentId, status, body };\n      }\n    });\n    if (wasWithChangesetresponse) {\n        return parsedData[0];\n    }\n    return parsedData;\n  }\n\n  /**\n   * If we determine a changset (POST, PUT, PATCH) we initalize a new\n   * OBatch instance for it.\n   */\n  private checkForChangset(resources: ORequest[], query: OdataQuery) {\n    const changeRes = this.getChangeResources(resources);\n\n    if (this.changeset) {\n      this.batchBody += [\n        \"\",\n        `Content-Type: multipart/mixed;boundary=${this.batchUid}`,\n        \"\",\n        `--${this.batchUid}`\n      ].join(CRLF);\n    } else if (changeRes.length > 0) {\n      this.batchBody = `--${this.batchUid}`;\n      this.batchBody += new OBatch(\n        changeRes,\n        this.batchConfig,\n        query,\n        true,\n      ).batchBody;\n      resources = this.getGETResources(resources);\n    } else {\n      this.batchBody = `--${this.batchUid}`;\n    }\n    return resources;\n  }\n\n  private getGETResources(resources: ORequest[]): ORequest[] {\n    return resources.filter((req) => req.config.method === \"GET\");\n  }\n\n  private getChangeResources(resources: ORequest[]): ORequest[] {\n    return resources.filter((req) => req.config.method !== \"GET\");\n  }\n\n  private getBody(req: ORequest) {\n    if (req.config.body) {\n      return `${req.config.body}${CRLF}${CRLF}`;\n    }\n    return \"\";\n  }\n\n  private getUid() {\n    let d = new Date().getTime();\n    const uuid = \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n      const r = (d + Math.random() * 16) % 16 | 0;\n      d = Math.floor(d / 16);\n      return (c === \"x\" ? r : (r & 0x7) | 0x8).toString(16);\n    });\n    return `${\n      this.changeset\n        ? this.batchConfig.batch.changsetBoundaryPrefix\n        : this.batchConfig.batch.boundaryPrefix\n    }${uuid}`;\n  }\n\n  private getHeaders(req: ORequest): string {\n  // Request headers can be Headers | string[][] | Record<string, string>.\n  // A new Headers instance around them allows treatment of all three types\n  // to be the same. This also applies security last two could bypass.\n  const headers = new Headers(req.config.headers || undefined) as any;\n  // Convert each header to single string.\n  // Headers is iterable. Array.from is needed instead of Object.keys.\n  const mapped = Array.from(headers).map(([k, v]) => `${k}: ${v}`);\n  if (mapped.length) {\n    // Need to ensure a blank line between HEADERS and BODY. When there are\n    // headers, it must be added here. Otherwise blank is added in ctor.\n    mapped.push(\"\");\n  }\n  return mapped.join(CRLF);\n  }\n\n  private getRequestURL(req: ORequest): string {\n  let href = req.url.href;\n  if (this.batchConfig.batch.useRelativeURLs) {\n    // Strip away matching root from request.\n    href = href.replace((this.batchConfig.rootUrl as URL).href, \"\");\n  }\n  return href;\n  }\n}\n","import { OBatch } from \"./OBatch\";\nimport { OdataConfig } from \"./OdataConfig\";\nimport { OdataQuery } from \"./OdataQuery\";\nimport { ORequest } from \"./ORequest\";\n\ntype BodyType =\n  | Blob\n  | BufferSource\n  | FormData\n  | URLSearchParams\n  | string\n  | object\n  | Object;\n\nexport class OHandler {\n  private requests: ORequest[] = [];\n\n  constructor(public config: OdataConfig) {}\n\n  /**\n   * Does a fetch request to the given endpoint and request\n   * all resources in sequent. Tries to parse the result logical\n   * so that no further processing is used. If the result is only one\n   * entity a object is returned, otherwise a array of objects.\n   *\n   * @example\n   * ```typescript\n   *  const russell = await o('https://services.odata.org/TripPinRESTierService/')\n   *  .get('People(\"russellwhyte\"))\n   *  .query();\n   *\n   *  console.log(russell); // shows: { FirstName: \"Russell\", LastName: \"Whyte\" [...] }\n   * ```\n   *\n   * If the request fails with an error code higher then 400 it throws the\n   * Response:\n   *\n   * @example\n   * ```typescript\n   *  try {\n   *    const unknown = await o('https://services.odata.org/TripPinRESTierService/')\n   *      .get('People(\"unknown\"))\n   *      .query();\n   *  } catch(res) { // Response\n   *    console.log(res.status); // 404\n   *  }\n   * ```\n   *\n   * @param query The URLSearchParams that are added to the question mark on the url.\n   *              That are usually the odata queries like $filter, $top, etc... or a string of parameters.\n   * @returns Either an array or a object with the given entities. If multiple\n   *          resources are fetched, this method returns a array of array/object. If there\n   *          is no content (e.g. for delete) this method returns the Response\n   */\n  public async query(query?: OdataQuery | string) {\n    try {\n      this.config.onStart(this);\n      const response: Response[] = await this.getFetch(query);\n      const json = await Promise.all(\n        response.map(async (res) => {\n          if (res.status >= 400) {\n            throw res;\n          } else if (res.ok && res.json) {\n            try {\n              this.config.onFinish(this, res);\n              const data = await res.json();\n              return data[this.config.fragment] || data;\n            } catch (ex) {\n              return res;\n            }\n          } else {\n            return await res.text();\n          }\n        })\n      );\n      return json.length > 1 ? json : json[0];\n    } catch (ex) {\n      this.config.onError(this, ex);\n      throw ex;\n    } finally {\n      this.requests = [];\n    }\n  }\n\n  /**\n   * Request all requests in sequent. Does simply return a Response or Response[]\n   * without any data parsing applied.\n   *\n   * @param query The URLSearchParams that are added to the question mark on the url.\n   *              That are usually the odata queries like $filter, $top, etc...\n   */\n  public async fetch(query?: OdataQuery | string) {\n    try {\n      this.config.onStart(this);\n      const fetch = await this.getFetch(query);\n      return fetch.length === 1 ? fetch[0] : fetch;\n    } catch (ex) {\n      this.config.onError(this, ex);\n      throw ex;\n    } finally {\n      this.config.onFinish(this);\n      this.requests = [];\n    }\n  }\n\n  /**\n   * Does a batch http-batch request. All request in that sequent are send via one\n   * physically request and afterwards parsed to separate data chunks.\n   *\n   * @param query The URLSearchParams that are added to the question mark on the url.\n   *              That are usually the odata queries like $filter, $top, etc...\n   */\n  public async batch(query?: OdataQuery) {\n    try {\n      const batch = new OBatch(this.requests, this.config, query);\n      const url = this.getUrl(this.config.batch.endpoint);\n      const data = await batch.fetch(url);\n      return data;\n    } catch (ex) {\n      this.config.onError(this, ex);\n      throw ex;\n    } finally {\n      this.requests = [];\n    }\n  }\n\n  /**\n   * Gets the data from the endpoint + resource url.\n   *\n   * @param resource The resource to request e.g. People/$value.\n   */\n  public get(resource: string = \"\") {\n    const url = this.getUrl(resource);\n    const request = new ORequest(url, { ...this.config, method: \"GET\" });\n    this.requests.push(request);\n    return this;\n  }\n\n  /**\n   * Post data to an endpoint + resource.\n   *\n   * @param resource The resource to post to.\n   * @param body The data to post.\n   */\n  public post(resource: string = \"\", body: BodyType) {\n    const url = this.getUrl(resource);\n    const request = new ORequest(url, {\n      ...this.config,\n      method: \"POST\",\n      body: this.getBody(body),\n    });\n    this.requests.push(request);\n    return this;\n  }\n\n  /**\n   * Put data to an endpoint + resource.\n   *\n   * @param resource The resource to put to.\n   * @param body The data to put.\n   */\n  public put(resource: string = \"\", body: BodyType) {\n    const url = this.getUrl(resource);\n    const request = new ORequest(url, {\n      ...this.config,\n      method: \"PUT\",\n      body: this.getBody(body),\n    });\n    this.requests.push(request);\n    return this;\n  }\n\n  /**\n   * Patch data to an endpoint + resource.\n   *\n   * @param resource The resource to patch to.\n   * @param body The data to patch.\n   */\n  public patch(resource: string = \"\", body: BodyType) {\n    const url = this.getUrl(resource);\n    const request = new ORequest(url, {\n      ...this.config,\n      body: this.getBody(body),\n      method: \"PATCH\",\n    });\n    this.requests.push(request);\n    return this;\n  }\n\n  /**\n   * Deletes a resource from the endpoint.\n   *\n   * @param resource The resource to delete e.g. People/1\n   */\n  public delete(resource = \"\") {\n    const url = this.getUrl(resource);\n    const request = new ORequest(url, { ...this.config, method: \"DELETE\" });\n    this.requests.push(request);\n    return this;\n  }\n\n  /**\n   * Use that method to add any kind of request (e.g. a head request) to\n   * the execution list.\n   *\n   * @example\n   * ```typescript\n   *   const req = new ORequest('http://full.url/healt', { method: 'HEAD'});\n   *   const res = await o('http://another.url').request(req).fetch();\n   *   console.log(res.status); // e.g. 200 from http://full.url/healt\n   * ```\n   * @param req The request to add.\n   */\n  public request(req: ORequest) {\n    this.requests.push(req);\n    return this;\n  }\n\n  /**\n   * Determines how many request are outstanding.\n   */\n  public get pending() {\n    return this.requests.length;\n  }\n\n  /**\n   * Returns a URL based on the rootURL + the given resource\n   * @param resource The resource to join.\n   */\n  public getUrl(resource: string) {\n    return new URL(resource, this.config.rootUrl);\n  }\n\n  private async getFetch(query: OdataQuery | string) {\n    if (this.pending > 1) {\n      const result: Response[] = [];\n      for (const req of this.requests) {\n        if (typeof query === \"string\") {\n          req.applyStringQuery(query, this.config.query);\n        } else {\n          req.applyQuery({ ...this.config.query, ...query });\n        }\n        const request = await req.fetch;\n        result.push(request);\n      }\n      return result;\n    } else {\n      if (typeof query === \"string\") {\n        this.requests[0].applyStringQuery(query, this.config.query);\n      } else {\n        this.requests[0].applyQuery({ ...this.config.query, ...query });\n      }\n      return [await this.requests[0].fetch];\n    }\n  }\n\n  private getBody(body: BodyType): any {\n    if (body instanceof Object) {\n      return JSON.stringify(body);\n    }\n    return body;\n  }\n}\n"],"names":["o","rootUrl","config","defaultConfigValues","batch","boundaryPrefix","changsetBoundaryPrefix","endpoint","headers","Headers","Content-Type","useChangset","useRelativeURLs","credentials","fragment","mode","redirect","referrer","window","undefined","onStart","onError","onFinish","mergedConfig","configUrl","location","href","URL","endsWith","ex","OHandler","encodeURIComponentStrict","str","encodeURIComponent","replace","c","charCodeAt","toString","toUpperCase","url","this","Object","ORequest","req","Request","fetch","query","configQuery","URLSearchParams","forEach","value","key","hasOwnProperty","applyQuery","searchParams","search","entries","map","_a","join","CRLF","resources","changeset","batchConfig","batchUid","getUid","set","checkForChangset","batchBody","method","contentId","_this","getRequestURL","getHeaders","getBody","OBatch","body","res","status","text","data","parseResponse","get","responseData","contentTypeHeader","split","boundary","length","splitData","shift","pop","wasWithChangesetresponse","parsedData","dataSegments","trim","header","find","x","startsWith","includes","contentIdHeader","parseInt","substring","parsed","JSON","parse","changeRes","getChangeResources","getGETResources","filter","d","Date","getTime","uuid","r","Math","random","floor","mapped","Array","from","push","getFetch","response","Promise","all","ok","json","ex_1","requests","fetch_1","ex_3","getUrl","ex_4","resource","request","pending","result","_i","applyStringQuery","_b","stringify"],"mappings":"w/CAuBgBA,GAAEC,EAAuBC,gBAAAA,KAEvC,IAAMC,IACJC,OACEC,eAAgB,SAChBC,uBAAwB,YACxBC,SAAU,SACVC,QAAS,GAAIC,UACXC,eAAgB,oBAElBC,aAAa,EACbC,iBAAiB,GAEnBC,YAAa,OACbC,SAAU,QACVN,QAAS,GAAIC,UACXC,eAAgB,qBAElBK,KAAM,OACNC,SAAU,SACVC,SAA4B,mBAAXC,YAAyBC,GAAY,SACtDC,QAAS,WAAM,MAAA,OACfC,QAAS,WAAM,MAAA,OACfC,SAAU,WAAM,MAAA,QAGZC,SAAiCpB,GAAwBD,EAC/D,IAAuB,gBAAZD,GACT,IAEE,GAAMuB,GAAaD,EAAatB,SAC9BiB,OAAOO,SAASC,IAClBzB,GAAU,GAAI0B,KACZ1B,EACAuB,EAAUI,SAAS,KAAOJ,EAAeA,OAE3C,MAAOK,GAEP5B,EAAU,GAAI0B,KAAI1B,EAAmBsB,EAAatB,SAItD,MADAsB,GAAatB,QAAUA,EAChB,GAAI6B,GAASP,yNC/DhBQ,EAA2B,SAACC,GAChC,MAAAC,oBAAmBD,GAAKE,QACtB,WACA,SAACC,GAAM,MAAA,IAAIA,EAAEC,WAAW,GAAGC,SAAS,IAAIC,8BAM1C,WAAYC,EAA0BrC,GAAAsC,YAAAtC,EAElCsC,KAAKD,IADY,gBAARA,GACE,GAAIZ,KAAIY,GAERA,EAkCjB,MA9BEE,uBAAWC,yBAAX,WACE,GAAMC,GAAM,GAAIC,SAAQJ,KAAKD,IAAIb,KAAMc,KAAKtC,OAC5C,OAAO2C,OAAMF,EAAKH,KAAKtC,yCAGlBwC,6BAAP,SAAwBI,EAAeC,GAOrC,oBAPqCA,MAChB,GAAIC,iBAAgBF,GAC5BG,QAAQ,SAACC,EAAOC,GACtBL,EAAMM,eAAeD,KACxBJ,EAAYI,GAAOD,KAGhBV,KAAKa,WAAWN,IAGlBL,uBAAP,SAAkBI,GAahB,oBAbgBA,MAChBN,KAAKD,IAAIe,aAAaL,QAAQ,SAACC,EAAOC,GAC/BL,EAAMM,eAAeD,KACxBL,EAAMK,GAAOD,KAIjBV,KAAKD,IAAIgB,OAASd,OAAOe,QAAQV,GAC9BW,IACC,SAACC,MAACP,QAAKD,MACL,OAAGnB,GAAyBoB,OAAQpB,EAAyBmB,KAEhES,KAAK,KACDnB,WC3CLoB,EAAO,oBAQX,WACEC,EACA3D,EACA4C,EACQgB,GAJV,wBAIUA,MAAAtB,eAAAsB,EARFtB,eAAY,GAUlBA,KAAKuB,mBAAmB7D,GAAWA,EAAOE,OAC1CoC,KAAKwB,SAAWxB,KAAKyB,SACpBzB,KAAKuB,YAAYvD,QAAoB0D,IACnC,eACA,6BAA6B1B,KAAKwB,UAGjCxB,KAAKuB,YAAY3D,MAAMO,YACzBkD,EAAYrB,KAAK2B,iBAAiBN,EAAWf,GAE7CN,KAAK4B,WAAa,KAAK5B,KAAKwB,SAG9BH,EAAUZ,QACR,SAACN,GAAQ,MAAsB,QAAtBA,EAAIzC,OAAOmE,QAAoB1B,EAAIU,WAAWP,IAEzD,IAAIwB,GAAY,CAChB9B,MAAK4B,WAAaP,EAAUJ,IAAI,SAACd,GAE/B,MADA2B,MAEE,GACA,iCACA,oCACA,eAAeA,EACf,GACG3B,EAAIzC,OAAOmE,WAAUE,EAAKC,cAAc7B,eAC3C,GAAG4B,EAAKE,WAAW9B,GACnB,GAAG4B,EAAKG,QAAQ/B,IAChBgB,KAAKC,KACND,KAAQC,OAASpB,KAAKwB,UAEzBxB,KAAK4B,WAAgBR,OAASpB,KAAKwB,cAAaJ,EAC5CE,GACDtB,KAAKuB,YAAYvD,QAAoB0D,IACpC,eACA,4BAA4B1B,KAAKwB,UAwJzC,MAnJeW,mBAAb,SAAmBpC,qGAMK,MALhBI,GAAM,GAAID,GAASH,SACpBC,KAAKuB,cACRa,KAAMpC,KAAK4B,UACXC,OAAQ,aAEkB1B,EAAIE,oBAA1BgC,GAAgBnB,SACH,MAAfmB,EAAIC,gBACaD,EAAIE,eACvB,MADMC,GAAOtB,YACNlB,KAAKyC,cAAcD,EAAMH,EAAIrE,QAAQ0E,IAAI,yBAEhD,KAAML,SAIHF,0BAAP,SAAqBQ,EAAsBC,GAA3C,WACQ5E,EAAU4E,EAAkBC,MAAM,aAClCC,EAAW9E,EAAQA,EAAQ+E,OAAS,GACpCC,EAAYL,EAAaE,MAAM,KAAKC,EAC1CE,GAAUC,QACVD,EAAUE,KACV,IAAIC,IAA2B,EACzBC,EAAaJ,EAAU/B,IAAI,SAACuB,GAChC,GAAMa,GAAeb,EAAKc,OAAOT,MAAM,WACvC,IAA4B,IAAxBQ,EAAaN,OAEf,MAAOP,EACF,IAAIa,EAAaN,OAAS,EAAG,CAClC,GAAMQ,GAASF,EAAaG,KACxB,SAACC,GAAM,MAAAA,GAAEC,WAAW,mBAAqBD,EAAEE,SAAS,gCACxD,OAAKJ,IAGLF,EAAaJ,QACbE,GAA2B,EACpBpB,EAAKU,cAAcY,EAAalC,KAAK,YAAaoC,IAJhDf,EAMT,GAAIoB,GAAkBP,EAAa,GAAGR,MAAM,QAAQW,KAAK,SAAUC,GAAK,MAAOA,GAAEC,WAAW,iBAC5F,IAAIE,EACF,IACE,GAAI9B,GAAY+B,SAASD,EAAgBE,UAAU,IAAK,IACxD,MAAOzE,IAGX,GAAIiD,IAAUe,EAAa,GAAGR,MAAM,KAAK,EACzC,IAA4B,IAAxBQ,EAAaN,OAAc,CAE7B,GAAIX,EACJ,KACE,GAAM2B,GAASC,KAAKC,MAAMZ,EAAa,GAEvCjB,GADoB2B,EAAOhC,EAAKR,YAAYjD,WACtByF,EACtB,MAAO1E,GACP+C,EAAOiB,EAAa,IAGxB,OAASvB,YAAWQ,SAAQF,SAGhC,OAAIe,GACOC,EAAW,GAEfA,GAODjB,6BAAR,SAAyBd,EAAuBf,GAC9C,GAAM4D,GAAYlE,KAAKmE,mBAAmB9C,EAqB1C,OAnBIrB,MAAKsB,UACPtB,KAAK4B,YACH,GACA,0CAA0C5B,KAAKwB,SAC/C,GACA,KAAKxB,KAAKwB,UACVL,KAAKC,GACE8C,EAAUnB,OAAS,GAC5B/C,KAAK4B,UAAY,KAAK5B,KAAKwB,SAC3BxB,KAAK4B,WAAa,GAAIO,GACpB+B,EACAlE,KAAKuB,YACLjB,GACA,GACAsB,UACFP,EAAYrB,KAAKoE,gBAAgB/C,IAEjCrB,KAAK4B,UAAY,KAAK5B,KAAKwB,SAEtBH,GAGDc,4BAAR,SAAwBd,GACtB,MAAOA,GAAUgD,OAAO,SAAClE,GAAQ,MAAsB,QAAtBA,EAAIzC,OAAOmE,UAGtCM,+BAAR,SAA2Bd,GACzB,MAAOA,GAAUgD,OAAO,SAAClE,GAAQ,MAAsB,QAAtBA,EAAIzC,OAAOmE,UAGtCM,oBAAR,SAAgBhC,GACd,MAAIA,GAAIzC,OAAO0E,KACN,GAAGjC,EAAIzC,OAAO0E,KAAOhB,EAAOA,EAE9B,IAGDe,mBAAR,WACE,GAAImC,IAAI,GAAIC,OAAOC,UACbC,EAAO,uCAAuC/E,QAAQ,QAAS,SAACC,GACpE,GAAM+E,IAAKJ,EAAoB,GAAhBK,KAAKC,UAAiB,GAAK,CAE1C,OADAN,GAAIK,KAAKE,MAAMP,EAAI,KACL,MAAN3E,EAAY+E,EAAS,EAAJA,EAAW,GAAK7E,SAAS,KAEpD,OAAO,IACLG,KAAKsB,UACDtB,KAAKuB,YAAY3D,MAAME,uBACvBkC,KAAKuB,YAAY3D,MAAMC,gBAC1B4G,GAGGtC,uBAAR,SAAmBhC,GAInB,GAAMnC,GAAU,GAAIC,SAAQkC,EAAIzC,OAAOM,aAAWW,IAG5CmG,EAASC,MAAMC,KAAKhH,GAASiD,IAAI,SAACC,GAAW,uBAMnD,OALI4D,GAAO/B,QAGT+B,EAAOG,KAAK,IAEPH,EAAO3D,KAAKC,IAGXe,0BAAR,SAAsBhC,GACtB,GAAIjB,GAAOiB,EAAIJ,IAAIb,IAKnB,OAJIc,MAAKuB,YAAY3D,MAAMQ,kBAEzBc,EAAOA,EAAKQ,QAASM,KAAKuB,YAAY9D,QAAgByB,KAAM,KAEvDA,qBC1LP,WAAmBxB,GAAAsC,YAAAtC,EAFXsC,iBAuPV,MAhNeV,mBAAb,SAAmBgB,4GAGc,8BAD7BN,KAAKtC,OAAOkB,QAAQoB,SACeA,KAAKkF,SAAS5E,WACpC,MADP6E,GAAuBjE,YACVkE,QAAQC,IACzBF,EAASlE,IAAI,SAAOoB,qGACdA,EAAIC,QAAU,KAAd,WACF,MAAMD,cACGA,EAAIiD,KAAMjD,EAAIkD,KAAd,6BAGM,6BADbvF,KAAKtC,OAAOoB,SAASkB,KAAMqC,MACRA,EAAIkD,eACvB,MADM/C,GAAOtB,YACNsB,EAAKxC,KAAKtC,OAAOY,WAAakE,UAErC,qBAAOH,6BAGF,SAAMA,EAAIE,eAAjB,SAAOrB,2CAIb,MAjBMqE,GAAOrE,YAiBNqE,EAAKxC,OAAS,EAAIwC,EAAOA,EAAK,WAGrC,iBADAvF,KAAKtC,OAAOmB,QAAQmB,KAAMwF,GACpBA,eAENxF,MAAKyF,uCAWInG,kBAAb,SAAmBgB,mGAGD,8BADdN,KAAKtC,OAAOkB,QAAQoB,SACAA,KAAKkF,SAAS5E,WAClC,MADMoF,GAAQxE,YACU,IAAjBwE,EAAM3C,OAAe2C,EAAM,GAAKA,UAGvC,iBADA1F,KAAKtC,OAAOmB,QAAQmB,KAAM2F,GACpBA,eAEN3F,MAAKtC,OAAOoB,SAASkB,MACrBA,KAAKyF,uCAWInG,kBAAb,SAAmBgB,uGAIF,8BAFP1C,EAAQ,GAAIuE,GAAOnC,KAAKyF,SAAUzF,KAAKtC,OAAQ4C,GAC/CP,EAAMC,KAAK4F,OAAO5F,KAAKtC,OAAOE,MAAMG,aACvBH,EAAMyC,MAAMN,WAC/B,MADMyC,GAAOtB,YACNsB,UAGP,iBADAxC,KAAKtC,OAAOmB,QAAQmB,KAAM6F,GACpBA,eAEN7F,MAAKyF,uCASFnG,gBAAP,SAAWwG,gBAAAA,KACT,IAAM/F,GAAMC,KAAK4F,OAAOE,GAClBC,EAAU,GAAI7F,GAASH,SAAUC,KAAKtC,SAAQmE,OAAQ,QAE5D,OADA7B,MAAKyF,SAASR,KAAKc,GACZ/F,MASFV,iBAAP,SAAYwG,EAAuB1D,gBAAvB0D,KACV,IAAM/F,GAAMC,KAAK4F,OAAOE,GAClBC,EAAU,GAAI7F,GAASH,SACxBC,KAAKtC,SACRmE,OAAQ,OACRO,KAAMpC,KAAKkC,QAAQE,KAGrB,OADApC,MAAKyF,SAASR,KAAKc,GACZ/F,MASFV,gBAAP,SAAWwG,EAAuB1D,gBAAvB0D,KACT,IAAM/F,GAAMC,KAAK4F,OAAOE,GAClBC,EAAU,GAAI7F,GAASH,SACxBC,KAAKtC,SACRmE,OAAQ,MACRO,KAAMpC,KAAKkC,QAAQE,KAGrB,OADApC,MAAKyF,SAASR,KAAKc,GACZ/F,MASFV,kBAAP,SAAawG,EAAuB1D,gBAAvB0D,KACX,IAAM/F,GAAMC,KAAK4F,OAAOE,GAClBC,EAAU,GAAI7F,GAASH,SACxBC,KAAKtC,SACR0E,KAAMpC,KAAKkC,QAAQE,GACnBP,OAAQ,UAGV,OADA7B,MAAKyF,SAASR,KAAKc,GACZ/F,MAQFV,mBAAP,SAAcwG,gBAAAA,KACZ,IAAM/F,GAAMC,KAAK4F,OAAOE,GAClBC,EAAU,GAAI7F,GAASH,SAAUC,KAAKtC,SAAQmE,OAAQ,WAE5D,OADA7B,MAAKyF,SAASR,KAAKc,GACZ/F,MAeFV,oBAAP,SAAea,GAEb,MADAH,MAAKyF,SAASR,KAAK9E,GACZH,MAMTC,sBAAWX,2BAAX,WACE,MAAOU,MAAKyF,SAAS1C,wCAOhBzD,mBAAP,SAAcwG,GACZ,MAAO,IAAI3G,KAAI2G,EAAU9F,KAAKtC,OAAOD,UAGzB6B,qBAAd,SAAuBgB,8GACjBN,KAAKgG,QAAU,GAAf,WACIC,UACY/E,EAAAlB,KAAKyF,gCAALS,aAAP/F,OACY,gBAAVG,GACTH,EAAIgG,iBAAiB7F,EAAON,KAAKtC,OAAO4C,OAExCH,EAAIU,kBAAgBb,KAAKtC,OAAO4C,OAAUA,OAEtBH,EAAIE,qBAApB0F,EAAUK,SAChBH,EAAOhB,KAAKc,0BAPIG,kBASlB,SAAOD,UAOC,MALa,gBAAV3F,GACTN,KAAKyF,SAAS,GAAGU,iBAAiB7F,EAAON,KAAKtC,OAAO4C,OAErDN,KAAKyF,SAAS,GAAG5E,kBAAgBb,KAAKtC,OAAO4C,OAAUA,OAE3CN,KAAKyF,SAAS,GAAGpF,cAA/B,UAAQ+F,iBAIJ9G,oBAAR,SAAgB8C,GACd,MAAIA,aAAgBnC,QACX+D,KAAKqC,UAAUjE,GAEjBA"}