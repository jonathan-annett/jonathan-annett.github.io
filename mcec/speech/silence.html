<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Silence Detector</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-color: #f0f0f0;
        }

        .indicator {
            font-size: 2em;
            padding: 20px;
            border: 2px solid #ccc;
            border-radius: 10px;
            display: none;
            background-color: #ffcccc;
            color: #a00;
        }

        .indicator.show {
            display: block;
        }

        #startBtn {
            position : absolute;
            top : 10px;
            left: 10px;
        }

        .info {

            position : absolute;
            bottom : 10px;
            left: 10px;
        }

        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .controls label, .controls input {
            margin: 10px;
        }
    </style>
</head>

<body>
    <button id="startBtn">start</button>

    <div id="silence-indicator" class="indicator">
        <p>SILENCE</p>
      
    </div>

    <div class="controls">
        <label for="threshold-slider">Threshold: <span id="threshold-value">0.01</span></label>
        <input type="range" id="threshold-slider" min="0" max="1" step="0.01" value="0.01">
    </div>

    <div class="info">&nbsp;</div>
    <script>
      class SilenceDetector0 {
            constructor(threshold = 0.01, silenceDuration = 5000) {
                this.threshold = threshold;
                this.silenceDuration = silenceDuration;
                this.silenceTimeout = null;
                this.isSilent = false;
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.init();
            }

            async init() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    this.audioInput = this.audioContext.createMediaStreamSource(stream);
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 256;
                    this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                    this.audioInput.connect(this.analyser);
                    this.monitor();
                } catch (error) {
                    console.error('Error accessing audio input:', error);
                }
            }

            monitor() {
                this.analyser.getByteFrequencyData(this.dataArray);
                let sum = 0;
                for (let i = 0; i < this.dataArray.length; i++) {
                    sum += this.dataArray[i];
                }
                const average = sum / this.dataArray.length;

                if (average < this.threshold * 256) {
                    if (!this.isSilent) {
                        if (this.silenceTimeout === null) {
                            this.silenceTimeout = setTimeout(() => {
                                this.isSilent = true;
                                this.emitEvent('silenceDetected', Date.now());
                            }, this.silenceDuration);
                        }
                    }
                } else {
                    if (this.isSilent) {
                        this.isSilent = false;
                        this.emitEvent('audioResumed', Date.now());
                    }
                    if (this.silenceTimeout !== null) {
                        clearTimeout(this.silenceTimeout);
                        this.silenceTimeout = null;
                    }
                }

                requestAnimationFrame(() => this.monitor());
            }

            emitEvent(eventType, timestamp) {
                const event = new CustomEvent(eventType, { detail: { timestamp } });
                window.dispatchEvent(event);
            }

            setThreshold(value) {
                this.threshold = value;
            }
        }



        class AudioMonitor {
                constructor(asilenceDetector, eventTimeout = 5000) {
                    this.silenceDetector = silenceDetector;
                    this.eventTimeout = eventTimeout;
                    this.lastSpeechEventTime = null;
                    this.audioActive = false;
                    
                    // Listen for silence detection events
                    window.addEventListener('silenceDetected', () => {
                        this.audioActive = false;
                    });

                    window.addEventListener('audioResumed', () => {
                        this.audioActive = true;
                        this.checkForWarning();
                    });

                    // Listen for custom TTS events
                    document.addEventListener('CustomSpeechEvent', (event) => {
                        this.lastSpeechEventTime = Date.now();
                        this.checkForWarning();
                    });
                }

                checkForWarning() {
                    if (this.audioActive && this.lastSpeechEventTime) {
                        const currentTime = Date.now();
                        if (currentTime - this.lastSpeechEventTime <= this.eventTimeout) {
                            this.emitWarningEvent();
                        }
                    }
                }

                emitWarningEvent() {
                    const warningEvent = new CustomEvent('WarningEvent', {
                        detail: {
                            message: 'Potential issue detected with the text-to-speech service.',
                            timestamp: Date.now()
                        }
                    });
                    document.dispatchEvent(warningEvent);
                }
            }

            class SilenceDetector {
                constructor(threshold = 0.01, silenceDuration = 5000) {
                    this.threshold = threshold;
                    this.silenceDuration = silenceDuration;
                    this.silenceTimeout = null;
                    this.isSilent = false;
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.init();
                }

                async init() {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        this.audioInput = this.audioContext.createMediaStreamSource(stream);
                        this.analyser = this.audioContext.createAnalyser();
                        this.analyser.fftSize = 256;
                        this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                        this.audioInput.connect(this.analyser);
                        this.monitor();
                    } catch (error) {
                        console.error('Error accessing audio input:', error);
                    }
                }

                monitor() {
                    this.analyser.getByteFrequencyData(this.dataArray);
                    let sum = 0;
                    for (let i = 0; i < this.dataArray.length; i++) {
                        sum += this.dataArray[i];
                    }
                    const average = sum / this.dataArray.length;

                    if (average < this.threshold * 256) {
                        if (!this.isSilent) {
                            if (this.silenceTimeout === null) {
                                this.silenceTimeout = setTimeout(() => {
                                    this.isSilent = true;
                                    this.emitEvent('silenceDetected', Date.now());
                                }, this.silenceDuration);
                            }
                        }
                    } else {
                        if (this.isSilent) {
                            this.isSilent = false;
                            this.emitEvent('audioResumed', Date.now());
                        }
                        if (this.silenceTimeout !== null) {
                            clearTimeout(this.silenceTimeout);
                            this.silenceTimeout = null;
                        }
                    }

                    requestAnimationFrame(() => this.monitor());
                }

                emitEvent(eventType, timestamp) {
                    const event = new CustomEvent(eventType, { detail: { timestamp } });
                    window.dispatchEvent(event);
                }

                setThreshold(value) {
                    this.threshold = value;
                }
            }

        // Usage example
        const startButton = document.querySelector('#startBtn');

        startButton.addEventListener('click', function () {
            startButton.disabled = true;

            const silenceDetector = new SilenceDetector(0.01, 5000);

            const silenceIndicator = document.getElementById('silence-indicator');
            const thresholdSlider = document.getElementById('threshold-slider');
            const thresholdValue = document.getElementById('threshold-value');

            const silenceInfo = document.querySelector('div.info');



            let updateTimeout;



            window.addEventListener('silenceDetected', (event) => {
                console.log('Silence detected at:', event.detail.timestamp);
                silenceIndicator.classList.add('show');
                if (updateTimeout) clearTimeout(updateTimeout);

                updateTimeout = setTimeout(function dispSeconds(silentAt) {
                    const elapsedMsec = Date.now() - silentAt;
                    const elapsed = (elapsedMsec / 1000).toFixed(1);
                    silenceInfo.innerHTML = `silent for ${elapsed} seconds`;
                    updateTimeout = setTimeout(dispSeconds, 100,silentAt);
                }, 100, event.detail.timestamp);
            });

            window.addEventListener('audioResumed', (event) => {
                console.log('Audio resumed at:', event.detail.timestamp);
                silenceIndicator.classList.remove('show');
                if (updateTimeout) {
                    clearTimeout(updateTimeout);
                    updateTimeout = undefined;
                    silenceInfo.innerHTML = `${silenceInfo.innerHTML}. audio resumed at ${new Date().toISOString()}`;
                }
            });

            thresholdSlider.addEventListener('input', (event) => {
                const newThreshold = parseFloat(event.target.value);
                silenceDetector.setThreshold(newThreshold);
                thresholdValue.textContent = newThreshold.toFixed(2);
            });



            const audioMonitor = new AudioMonitor(silenceDetector, 5000);

            document.addEventListener('WarningEvent', (event) => {
                console.log('Warning:', event.detail.message, 'at', new Date(event.detail.timestamp));
            });
        });
    </script>
</body>

</html>