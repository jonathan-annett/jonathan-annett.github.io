
<html>
    
    <head>
        
        
        
          <script>
                
           // source - browser version
           /*global self*/
          function ml(x,L,o,a,d,s){
                  if (!ml.h){ml.h={};ml.H=[];ml.d={};}//create history db if none exists
                  let
                  C=console,//shortcut for console
                  z,
                  // "t" contains an array of types - object,function,string,undefined
                  // used for comparisions later
                  t=[C,ml,'',z,x].map((G)=>typeof G),
                  l=location,O=l.origin,
                  X=t[4]===t[2]?'L':x,//X =: x is string ? 6, otherwise x
                  // "c" contains initial parameter parser(wraps for argument calls eg ml(1), ml(2), and 
                  // any constants/worker functions they need. also contains some code used later by z
                  // note that z doubles as a proxy for "undefined" in the type array "t" above 
                  c = {// holder for "constants", also a few holds outer scope commands, common functions
                      //c.r = regex:splits "mod | /url" --> [ "mod | url" ,"mod","", /url"] or null
                      //c.r = regex:splits "mod@Window | /url" --> [ "mod | url" ,"mod","Window", /url"] or null
                      r:(u)=>/([A-z]*)(?:\@)?([\w\$]*)(?:\s*\|)(?:\s*)([A-z0-9\:\/\-\_\.\@\~\#\!]+)/.exec(u),
                      //c.b=document base
                      b:O+/([a-zA-Z0-9\.\-]*\/)*/.exec(l.pathname)[0],
                      //c.R=shortcut to replace keyword
                      R:'replace',
                      //c.B=rebase  paths that start with ./subpath/file.js or subpath/file.js
                      B:(u,r)=>(r=/^\//)&&/^(http(s?)\:\/\/)/.test(u)?u:r.test(u)?u[c.R](r,O+'/'):c.b+u[c.R](/^(\.\/)/,''),
              
                      // ml(1)->c[1] = resolve to self or an empty object - becomes exports section
                      
                      1:()=>c[4]()||{},
                      
                      
                      // ml(2)-->c[2](L,o,a,d,e,r) 
                      
                      // L = "Window", "ServiceWorkerGlobalScope" (result of ml(1)--> c[1]
                      // o = exports (ie self ie window)
                      // a = dictionary of dependants per window type
                      // d = array of loaded dependants 
                      // e = unuused argument doubles as a variable
                      // r = undefined
                      2:(L,o,a,d,e,r)=>{
                              e = a[L] && a[L].name; 
                              e=typeof e+typeof o[e]===t[2]+t[3]? Object.defineProperty(o, e, {
                              value: a[L].apply(this, d[L].map(c.x)),
                              enumerable: !0,
                              configurable: !0
                          })&&c.l("defined:",e) : c.l("ready:",e);
                          
                      },
                      
                      // ml(3)->c[1] = resolve to whatever self is (Window,ServiceWorkerGlobalScope or Object if self was not assigned)
                      3:()=>c[4]().constructor.name || "x",
                      
                      // ml(1)->c[1] = resolve to self or undefined
                      4:()=>typeof self === t[0] && self,
                      
                      //c.x = map iterator to execure every function in an array of functions
                      //      (used to resolve each loaded module)
                      x:(f)=>f(),
                      //c.l = console.log shortcut
                      l:C.log.bind(C),
                      //c.L = loader hoist function (called when first argument to ml is a string)
                      L:(S,R,t,w)=>{
                          // ml("/path/to/mod.js",function(mod){...}) 
                          //   ==>  x="/path/to/mod.js", L=function(mod){ /* do something with mod*/ }
                          // ml("/path/to/mod.js",function(mod){...},window,"modName") 
                          //   ==>  x="/path/to/mod.js", L=function(mod){ /* do something with mod*/ } o=window,a="modName"
                          R=c.r(x);
                          w=R?c[4]():!!o;
                          S=w?o:{};  // S=dummy self, contains "t" temporarily
                                 // R=holder for S.t between deletion and return
                          R=R||[x,'t',0,x];// [fullurl,tempname,ignored,url]
                          t=a||R[1];
                          return ml(
                              0,S,[
                              t+"@T|"+R[3]],
                              ()=>ml(  2,'T',S,
                                      {T:L},
                                      {T:[()=>{ R=S[t];
                                                if (!w) delete S[t];
                                                return R;
                                               }
                                         ]}),
                              'T'
                          );
                      },
                      w:'serviceWorker',
                      n:'navigator'
                  };
                  // here X will be 5 if first arg(x) is a string, ie a file name to be loaded. otherwise X will be x
                  z=typeof c[X]===t[1]?c[X](L,o,a,d,s):c;// if c[X] resolves to a function, execute it, putting result in z, otherwise set z to c
                  
                  if (z!==c)return z;// if z === c it's because c[X] was not a function, so we need to loook further, otherwise exit
                      
                  z = {
                     F:ml.fetch||false,// F:t[1] = use fetch, F:false,  = don't use fetch
                     
                     //ml(0)->z[0] = entry vector - note we ignore params passed to ()=> use outer scope to fetch o
                     //     (o is the result of z[1]() which was invoked earlier in outer script scope, when it called ml(1) 
                     0:()=>z.l(o),
                     
                     t:(n)=>Math.min(100,ml.t=(ml.t?ml.t*2:1)),
                     //z.l = load list of urls, then call outer (a) function (the module ready completion callback)
                     l:(u)=>{
                           u = u.map(z.u).filter(z.y);
                           return u.length?setTimeout(z.l, z.t(u.length), u)&&c.l("pending...",u):a();
                     },
              
                     //z.u = map iterator z.l
                     u:(x,R,U,N)=>{
                           R=c.r(x);
                           if (!R) return L[x]?false:ml.d[x]||x;
                           // for module@Window|filename.js format - return if wrong name:  c[3]() is "Window","ServiceWorkerGlobalScope"
                           if ((N=R[2])&&N!==(d||c[3]())) return false; 
                           s = z.T(window,"script");
                           U=ml.d[ N=R[1] ]=c.B(R[3]);
                           z.p(U,s.setAttribute.bind(s,"src"));
                           return N;
                     },
                     
                     //z.y = filter to remove elements that truthy. (z.m returns false when a module is loaded, so truthy = name of still to be loaded module)
                     y:(x)=>!!x,
                       
                     //z.s = create and append empty script element
                     s:(d,S)=>{s = z.E(d,S);s.type = "text/java"+S; return z.A(d,s);},
                     //z.s = create empty script in it's own empty iframe
                     S:(w,s,D)=>{D="document";return z.s(z.f(w[D]).contentWindow[D],s);},
                     T:(w,s)=>z.s(w.document,s),
                     //z.E = create script element
                     E:(d,S)=>d.createElement(S),
                     //z.A = append element x to document d
                     A:(d,x)=>d.body.appendChild(x),
                     //z.f = create hidden iframe
                     f:(d,i)=>{ i=z.E(d,"iframe");
                                i.style.display="none";
                                i.src="ml.html";
                                return z.A(d,i);},
           

          
                     //document.getElementById('targetFrame').contentWindow.targetFunction();
                     
                   
          
                     
                            
                     //z.U() = history as an array of urls
                     U:()=>Object.keys(ml.h),
                     
                     
                     //z.p = prefetch script to bust cache, and then load call l() which assigns url to src attribute of script element
                     p:(u,l/*vars->*/,r,L,V,R)=>{//u = url, l() = load script, r=randomId, C= load script with version, R=call V with r
                         r=z.r();//prepare a random version number (in case we need it)
                         L=(v)=>l(z.V(u,v));                  // load script with version
                         V=(v)=>L(z.v(u,v));                   // save version v in history, load script with version
                         R=()=>V(r);                           // save random verison in history, load scipt with random version
                         return (ml.h[u] ?                     // does url exist in history? 
                                    V(ml.h[u])                  //yes = load script using version from history
                                  : ml.H.push(u) && ( typeof fetch===z.F ?    // did Gretchen make fetch happen ? 
                                        fetch(u,{method: 'HEAD'}) // yes= fetch header and 
                                          .then((h)=>V(z.e(h,r))) // use etag as version, or random if no etag
                                          .catch(R)                               // if fetch(HEAD) fails,use random version
                                      : R())                     // Gretchen didn't make fetch happen. so random.
                                );
                     },
                     //z.e = resolve to etag in r.header or d (default)
                     e:(r,d)=>r.headers.get("Etag")[c.R](/[\"\/\\\-]*/g,'')||d,
                     
                     //z.r() = a random id generator
                      r:()=>Math.random().toString(36).substr(-8),
                      
                     
                     V:(u,v)=>z.F?u+"?v="+v:u,// if using fetch,  append v=version
                     v:(u,v)=>(ml.h[u]=v),
                     w:'serviceWorker',
                     W:'navigator',
                     8:(m,c)=>{
                         
                     },
                     9:(L)=>L&&c.w in self[c.n]&&self[c.n][c.w].register('./ml.sw.min.js?ml=' + encodeURIComponent(L))
                  };
                  return z[x]&&z[x](L,o,a,d,s);
              }
        
          
         </script>
        
        
        <style>
            
            textarea {
                
                width : 100vw;
                height : 100vh;
            }
        </style>
    </head>
    
    <body>
        <div id="control-height"></div>
        
        <label> url
           <input type="text" id="url" value="/zed/pwa/test.html" placeholder="url"\>
        </label>
        <label> title
           <input type="text" id="title" value="a title" placeholder="title"\>
        </label>
        
        <label> left
           <input type="text" id="left" value="10" placeholder="left"\>
        </label>
        
        <label> top
           <input type="text" id="top" value="10" placeholder="top"\>
        </label>
        <button id="btnOpen">open</button>
        <select></select>
        <button id="btnMax">max</button>
        <button id="btnMin">min</button>
        <button id="btnRestore">restore</button>
        <textarea>
            
        </textarea>
        <!--
        <script src="windowTools.helper.js" ></script>
        -->
        <script>
       
            ml(0,ml(1),[
                "localforage | https://unpkg.com/localforage@1.9.0/dist/localforage.js",
                'dbengine    | dbengine.js',
                'wToolsRem   | windowTools.remote.js',
                'wToolsLib   | windowTools.helper.js',
                'main        | wtool.js',
                'libEvents   | events.js'
                ],()=>{ml(2,ml(3),ml(4),
            
                { Window: (main) => main }, 
                
                { Window: [ () => self.main ] }
                
               
            
            );
            

            });
           
            /*
           
           ml("wtool.js",function main (main){
               console.log("we good",main);
           });
       
          */
            
        </script>
    </body>
    
</html>