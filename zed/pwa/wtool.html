<html>
    
    <head>
        <script>

//minified
function ml2(x,L,o,a,d,s){ml.h=ml.h||{};let e,t=[{},ml,"",e].map(e=>typeof e),m={1:()=>m[4]()||{},2:(L,o,a,d,e,n)=>{e=typeof(e=a[L]&&a[L].name)+typeof o[e]===t[2]+t[3]?Object.defineProperty(o,e,{value:a[L].apply(this,d[L].map(m.x)),enumerable:!0,configurable:!0}):n},3:()=>m[4]().constructor.name||"x",4:()=>typeof self===t[0]&&self,x:e=>e(),r:()=>Math.random().toString(36).substr(-8)};return(e=typeof m[x]===t[1]?m[x](L,o,a,d,s):m)!==m?e:(e={0:()=>e.l(o),l:t=>(t=t.map(e.u).filter(e.y)).length?setTimeout(e.l,10*t.length,t):a(),u:(x,t)=>(t=e.r(x))?(s=e.s(this.document,"script"),d&&d(s),e.p(t[2],s.setAttribute.bind(s,"src")),t[1]):!L[x]&&x,y:x=>!!x,s:(d,e)=>((s=d.createElement(e)).type="text/java"+e,d.body.appendChild(s)),p:(e,l,n,L,r,c)=>(n=m.r(),L=(t=>l(e+"?v="+t)),r=(t=>L(ml.h[e]=t.replace(/[\"\/\\\-]*/g,""))),c=(()=>r(n)),ml.h[e]?r(ml.h[e]):typeof fetch===t[1]?fetch(e,{method:"HEAD"}).then(e=>r(e.headers.get("Etag")||n)).catch(c):c()),r:e=>/([\w\$]*)(?:\s*\|)(?:\s*)([A-z0-9\:\/\-\_\.]+)/.exec(e),5:()=>(L.ml||(L.ml=ml.bind(L)),ml.call(L,0,L,o,a,d,s)),6:()=>ml.call(L,5,L,[o+"|"+a],function(){ml(2,"x",L,{x:s},{x:[function(){return L[o]}]})},d)})[x](L,o,a,d,s)}

// source
function ml(x,L, o, a, d, s){
    ml.h=ml.h||{};//create history db if none exists
    let
    z,
    t=[{},ml,'',z].map((G)=>typeof G),
    c = {
        // ml(1)->c[1] = resolve to self or an empty object - becomes exports section
        1:()=>c[4]()||{},
        
        // ml(2)-->c[2](L,o,a,d,e,r) 
        
        // L = "Window", "ServiceWorkerGlobalScope" (result of ml(1)--> c[1]
        // o = exports (ie self ie window)
        // a = dictionary of dependants per window type
        // d = array of loaded dependants 
        // e = unuused argument doubles as a variable
        // r = undefined
        2:(L,o,a,d,e,r)=>{
                e = a[L] && a[L].name; e=typeof e+typeof o[e]===t[2]+t[3]? Object.defineProperty(o, e, {
                value: a[L].apply(this, d[L].map(c.x)),
                enumerable: !0,
                configurable: !0
            }) : r;
        },
        
        // ml(3)->c[1] = resolve to whatever self is (Window,ServiceWorkerGlobalScope or Object if self was not assigned)
        3:()=>c[4]().constructor.name || "x",
        
        // ml(1)->c[1] = resolve to self or undefined
        4:()=>typeof self === t[0] && self,
        
        //c.x = map iterator to execure every function in an array of functions
        //      (used to resolve each loaded module)
        x:(f)=>f(),
        r:()=>Math.random().toString(36).substr(-8)
          
    };
    z=typeof c[x]===t[1]?c[x](L,o,a,d,s):c;
    
    if (z!==c)return z;
        
    z = {
        
       //ml(0)->z[0] = entry vector - note we ignore params passed to ()=> use outer scope to fetch o
       //     (o is the result of z[1]() which was invoked earlier in outer script scope, when it called ml(1) 
       0:()=>z.l(o),
       
       //z.l = load list of urls, then call outer (a) function (the module ready completion callback)
       l:(u)=>{
             u = u.map(z.u).filter(z.y);
             return u.length?setTimeout(z.l, u.length*10, u):a();
       },

       //z.u = map iterator z.l (note - R argument is a cheat - used as local var, originally index for interator)
       u:(x,R)=>{
             R=z.r(x);
             if (!R) return L[x]?false:x;
             s = z.s(this.document,"script");
             if(d)d(s);
             z.p(R[2],s.setAttribute.bind(s,"src"));
             return R[1];
       },
       
       //z.y = filter to remove elements that truthy. (z.m returns false when a module is loaded, so truthy = name of still to be loaded module)
       y:(x)=>!!x,
      
         
       //z.s = create and append empty script element
       s:(d,S)=>{s = d.createElement(S);s.type = "text/java"+S; return d.body.appendChild(s);},
       
       //z.p = prefetch script to bust cache, and then load call l() which assigns url to src attribute of script element
       p:(u,l/*vars->*/,r,L,V,R)=>{//u = url, l() = load script, r=randomId, C= load script with version, R=call V with r
           r=c.r();//prepare a random version number (in case we need it)
           L=(v)=>l(u+"?v="+v); // load script with version
           V=(v)=>L(ml.h[u]=v.replace(/[\"\/\\\-]*/g,''));// save version v in history, load script with version
           R=()=>V(r);                          // save random verison in history, load scipt with random version
           return (ml.h[u] ?                     // does url exist in history? 
                      V(ml.h[u])                  //yes = load script using version from history
                    : ( typeof fetch===t[1] ?    // did Gretchen make fetch happen ? 
                          fetch(u,{method: 'HEAD'}) // yes= fetch header and 
                            .then((h)=>V(h.headers.get("Etag")||r)) // use etag as version, or random if no etag
                            .catch(R)                               // if fetch(HEAD) fails,use random version
                        : R())                     // Gretchen didn't make fetch happen. so random.
                  );                 
           
       },
       
       //z.r = regex:splits "mod | /url" --> [ "mod | url" ,"mod","/url"] or null
       r:(u)=>/([\w\$]*)(?:\s*\|)(?:\s*)([A-z0-9\:\/\-\_\.]+)/.exec(u),
       
        
       //experimental, probably buggy, extra script loader. needs some work
       5:()=>{if (!L.ml) L.ml=ml.bind(L);return ml.call(L,0,L,o,a,d,s);},
       
       //experimental, probably buggy, extra script loader. needs some work
       6:()=>ml.call(L,5,L,[o+"|"+a],function(){ml(2,"x",L,{x:s},{x:[function(){return L[o];}]});},d)
  
    };
    return z[x](L,o,a,d,s);
    
}
        </script>
         

        <style>
            
            textarea {
                
                width : 100vw;
                height : 100vh;
            }
        </style>
    </head>
    
    <body>
        <div id="control-height"></div>
        
        <label> url
           <input type="text" id="url" value="/zed/pwa/test.html" placeholder="url"\>
        </label>
        <label> title
           <input type="text" id="title" value="a title" placeholder="title"\>
        </label>
        
        <label> left
           <input type="text" id="left" value="10" placeholder="left"\>
        </label>
        
        <label> top
           <input type="text" id="top" value="10" placeholder="top"\>
        </label>
        <button id="btnOpen">open</button>
        <select></select>
        <button id="btnMax">max</button>
        <button id="btnMin">min</button>
        <button id="btnRestore">restore</button>
        <textarea>
            
        </textarea>
        <!--
        <script src="windowTools.helper.js" ></script>
        -->
        <script src="windowTools.js" defer></script>
        <script src="wtool.js" defer></script>
    </body>
    
</html>